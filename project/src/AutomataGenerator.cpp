/*
 * Michele Dusi, Gianfranco Lamperti
 * Quick Subset Construction
 * 
 * AutomataGenerator.cpp
 *
 * 
 * Implementation of the class AutomataGenerator, which is responsible for generating automata
 * of different types and characteristics, according to the parameters passed to the constructor.
 */

#include "AutomataGenerator.hpp"

#include <string>
#include <cstring>
#include <vector>

#include "Debug.hpp"

namespace quicksc {

	const unsigned long int AutomataGenerator::default_size = 2UL;

	const char* AutomataGenerator::default_name_prefix = "s";

	const double AutomataGenerator::default_transition_percentage = 0.5;

	const double AutomataGenerator::default_final_probability = 0.1;

	/**
	 * Constructor.
	 * Since the alphabet is generated by another class, it is better to make this class independent from it.
	 * For this reason, the constructor accepts an already generated alphabet.
	 * The programmer can change the alphabet with the setter methods.
	 */
	AutomataGenerator::AutomataGenerator(Alphabet alphabet, Configurations* configurations) {
		DEBUG_MARK_PHASE("Costruzione di un generatore di automi") {
		this->m_alphabet = alphabet;
		this->m_automaton_structure = (AutomatonType) configurations->valueOf<int>(AutomatonStructure);
		this->m_size = configurations->valueOf<int>(AutomatonSize);
		this->m_name_prefix	= default_name_prefix;
		this->m_transition_percentage = configurations->valueOf<double>(AutomatonTransitionsPercentage);
		this->m_epsilon_probability = configurations->valueOf<double>(EpsilonPercentage);
		this->m_final_probability = configurations->valueOf<double>(AutomatonFinalProbability);
		this->m_max_distance = configurations->valueOf<int>(AutomatonMaxDistance);
		this->m_safe_zone_distance = configurations->valueOf<int>(AutomatonSafeZoneDistance);
		}
	}

	/**
	 * Destructor.
	 */
	AutomataGenerator::~AutomataGenerator() {
		this->m_alphabet.clear();
	}

	/**
	 * Protected method.
	 * Allows to reset the space of names used for the states of an automaton.
	 * If called at the end of the generation of each automaton, it has the effect of starting the generation process
	 * from zero during the next generation.
	 */
	void AutomataGenerator::resetNames() {
		this->m_namesCounter = 0;
	}

	/**
	 * Protected method.
	 * Builds a unique name from the last reset.
	 * The name is built by concatenating a string with an incremental number, and is used to uniquely identify the states of an automaton.
	 */
	string AutomataGenerator::generateUniqueName() {
		string name = this->m_name_prefix + string(std::to_string(this->m_namesCounter++));
		return name;
	}

	/**
	 * Protected method.
	 * Returns a double-precision floating-point number, between 0 and 1.
	 * It can be used to make choices by comparing it with a predefined probability.
	 */
	double AutomataGenerator::generateNormalizedDouble() {
		return (static_cast <double> (rand()) / static_cast <double> (RAND_MAX));
	}

	/**
	 * Protected method.
	 * Returns a random label chosen from the labels of the alphabet set for the generation of automata.
	 */
	string AutomataGenerator::getRandomLabelFromAlphabet() {
		return (m_alphabet[rand() % m_alphabet.size()]);
	}

	/**
	 * Protected method.
	 * Calculates the number of deterministic transitions to be created inside the automaton.
	 * The number of deterministic transitions is calculated by excluding the possibility that a state has more than one outgoing transition with the same label;
	 * for this reason, we call them "deterministic transitions".
	 * The maximum number of deterministic transitions (on which the percentage is calculated) is given by the number of states multipled by the number of possible labels,
	 * i.e. the cardinality of the alphabet.
	 * 
	 * More specifically, the calculation is performed according to the following algorithm:
	 * - The maximum number of transitions is calculated. This number corresponds to the maximum number of transitions for each state multiplied by the number N of states.
	 *  The maximum number of transitions for a single state is given by the number L of labels available (remember that we are only considering deterministic transitions).
	 * - The requested percentage is calculated on this number, rounded down.
	 * - If the resulting number is lower than the number needed to connect all the states, it is raised up to the number of states - 1.
	 * 
	 * Note: in the case of non-deterministic automata (NFA), it is possible to insert a percentage greater than 1 to generate more than one transition with the same label
	 * (see the documentation of the NFAGenerator class).
	 */
	unsigned long int AutomataGenerator::computeDeterministicTransitionsNumber() {
		unsigned long int max_n_trans = (this->getSize()) * (this->getAlphabet().size());
		unsigned long int n = (unsigned long int) (max_n_trans * this->getTransitionPercentage());
		return (n < this->getSize() - 1) ? (this->getSize() - 1) : (n);
	}

	/**
	 * Getter method.
	 * Returns the alphabet used to generate the automata.
	 */
	Alphabet AutomataGenerator::getAlphabet() {
		return this->m_alphabet;
	};

	/**
	 * Getter method for the automaton structure.
	 */
	AutomatonType AutomataGenerator::getAutomatonStructure() {
		return this->m_automaton_structure;
	};

	/**
	 * Getter method for the size of the automaton.
	 */
	unsigned long int AutomataGenerator::getSize() {
		return this->m_size;
	}

	/**
	 * Getter method for the prefix of the names of the states of the automaton.
	 */
	string AutomataGenerator::getNamePrefix() {
		return this->m_name_prefix;
	}

	/**
	 * Getter method for the percentage of transitions to be generated.
	 */
	double AutomataGenerator::getTransitionPercentage() {
		return this->m_transition_percentage;
	}

	/**
	 * Getter method for the probability of generating an epsilon transition.
	 */
	double AutomataGenerator::getEpsilonProbability() {
		return this->m_epsilon_probability;
	}

	/**
	 * Getter method for the probability of generating a final state, i.e. the probability that a state is final.
	 */
	double AutomataGenerator::getFinalProbability() {
		return this->m_final_probability;
	}

	/**
	 * Getter method for the maximum distance of a state inside the automaton.
	 * This parameter is used only for the generation of stratified automata.
	 */
	unsigned int AutomataGenerator::getMaxDistance() {
		return this->m_max_distance;
	}

	/**
	 * Getter method for the safe zone distance of a state inside the automaton.
	 * This parameter is used only for the generation of stratified automata.
	 */
	void AutomataGenerator::setMaxDistance(unsigned int max_distance) {
		this->m_max_distance = max_distance;
	}

	/**
	 * Getter method for the safe zone distance.
	 * This is the distance within which it is not possible to find non-deterministic points, in the case of stratified NFA automata that provide for such a possibility.
	 */
	unsigned int AutomataGenerator::getSafeZoneDistance() {
		return this->m_safe_zone_distance;
	}

	/**
	 * Returns an automaton of the desired type.
	 * In short, this method is responsible for delegating the creation of the automaton to the other methods of the class, 
	 * depending on the value of the requested parameter. The other methods will then be implemented in the child classes.
	 * 
	 * AutomatonGenerator provides a basic implementation of the methods for building automata of various types,
	 * but they are fake implementations that generate an exception. This allows you to immediately understand if a certain automaton structure is available
	 * for DFA automata or for NFA automata.
	 */
	Automaton* AutomataGenerator::generateAutomaton() {
		switch(this->getAutomatonStructure()) {

		case AUTOMATON_RANDOM :
			return this->generateRandomAutomaton();

		case AUTOMATON_STRATIFIED :
			return this->generateStratifiedAutomaton();

		case AUTOMATON_STRATIFIED_WITH_SAFE_ZONE :
			return this->generateStratifiedWithSafeZoneAutomaton();

		case AUTOMATON_ACYCLIC :
			return this->generateAcyclicAutomaton();

		default :
			DEBUG_LOG_ERROR("Valore %d non riconosciuto all'interno dell'enumerazione AutomatonType", this->getAutomatonStructure());
			return NULL;
		}
	}

	Automaton* AutomataGenerator::generateRandomAutomaton() {
		DEBUG_LOG_ERROR("Impossibile generare un automa di tipo \"Random\" per l'attuale tipologia di problema");
		throw "Impossibile generare un automa di tipo \"Random\" per l'attuale tipologia di problema";
	}

	Automaton* AutomataGenerator::generateStratifiedAutomaton() {
		DEBUG_LOG_ERROR("Impossibile generare un automa di tipo \"Stratified\" per l'attuale tipologia di problema");
		throw "Impossibile generare un automa di tipo \"Stratified\" per l'attuale tipologia di problema";
	}

	Automaton* AutomataGenerator::generateStratifiedWithSafeZoneAutomaton() {
		DEBUG_LOG_ERROR("Impossibile generare un automa di tipo \"StratifiedWithSafeZone\" per l'attuale tipologia di problema");
		throw "Impossibile generare un automa di tipo \"StratifiedWithSafeZone\" per l'attuale tipologia di problema";
	}

	Automaton* AutomataGenerator::generateAcyclicAutomaton() {
		DEBUG_LOG_ERROR("Impossibile generare un automa di tipo \"Acyclic\" per l'attuale tipologia di problema");
		throw "Impossibile generare un automa di tipo \"Acyclic\" per l'attuale tipologia di problema";
	}


} /* namespace quicksc */
