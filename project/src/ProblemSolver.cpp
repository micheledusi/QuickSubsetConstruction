/*
 * Michele Dusi, Gianfranco Lamperti
 * Quick Subset Construction
 * 
 * ProblemSolver.cpp
 *
 * 
 * This module manages the solving of the problems, with a general approach.
 * The problems are generated by the ProblemGenerator class and solved by the provided algorithms.
 * The results are then collected in a ResultsCollector object.
 */

#include "ProblemSolver.hpp"

#include <cstdio>
#include <list>

#include "Timer.hpp"
#include "Debug.hpp"
#include "Properties.hpp"

using namespace std;

namespace quicksc {

	/**
	 * Macro function that concatenates two tokens.
	 */
	#define CONCAT( x, y ) _CONCAT( x, y )
	#define _CONCAT( x, y ) x ## y

	/**
	 * Constructor.
	 * It requires the program configurations, the list of algorithms to be used to solve the problems.
	 * The algorithm used for comparisons is by default the first algorithm of the list.
	 */
	ProblemSolver::ProblemSolver(Configurations* configurations, const vector<DeterminizationAlgorithm*>& algorithms)
			: algorithms(algorithms) {

		// Creating the generator and the results collector
		this->generator = new ProblemGenerator(configurations);
		this->collector = new ResultCollector(configurations, this->algorithms);

		// By default, the first algorithm is used for comparisons (the first algorithm is the "Benchmark" algorithm)
		this->benchmark_algorithm_pointer = this->algorithms.front();
	}

	/**
	 * Destructor.
	 * It deletes the generator and the collector.
	 */
	ProblemSolver::~ProblemSolver() {
		DEBUG_MARK_PHASE("Eliminazione del risolutore") {
			delete this->generator;
			delete this->collector;
//			delete this->algorithms; // This is not necessary, since the algorithms are not owned by the ProblemSolver
		}
	}

	/**
	 * Returns the collector of the results.
	 */
	ResultCollector* ProblemSolver::getResultCollector() {
		return this->collector;
	}

	/**
	 * Solves a single determinization problem with all the algorithms.
	 * For now, the algorithms are:
	 * - Subset Construction, i.e. the "Benchmark" algorithm
	 * - Quick Subset Construction
	 */
	void ProblemSolver::solve(DeterminizationProblem* problem) {
		DEBUG_ASSERT_NOT_NULL(problem);
		Result* result = new Result();
		result->original_problem = problem;
		result->benchmark_algorithm = this->benchmark_algorithm_pointer;

		for (DeterminizationAlgorithm* algo : this->algorithms) {
			algo->resetRuntimeStatsValues();

			DEBUG_MARK_PHASE("Esecuzione dell'algoritmo") {
				// Construction phase
				MEASURE_NANOSECONDS( time ) {
					result->solutions[algo] = algo->run(problem->getNFA()); // Algorithm execution
				}
				// Statistics
				result->times[algo] = time;
			}
			result->runtime_stats[algo] = algo->getRuntimeStatsValues();
		}

		this->collector->addResult(result);
	}

	/**
	 * Solves a single instance of a generic problem, depending on the type of the problem.
	 * In practice, it delegates the solving to the specific methods for the problem type.
	 *
	 * NOTE: at the moment, only one type of problems is supported: determinization problems.
	 * The previous translation problems, which were applied to the ESC algorithm, have been removed.
	 */
	void ProblemSolver::solve(Problem* problem) {
		DEBUG_ASSERT_NOT_NULL(problem);
		switch (problem->getType()) {

		case Problem::DETERMINIZATION_PROBLEM :							// Currently, only determinization problems are supported
			return this->solve((DeterminizationProblem*) problem);

		default :
			DEBUG_LOG_ERROR("Cannot parse value %d as instance of the ProblemTyoe enumeration", problem->getType());
			throw "Unknown value for the ProblemType enumeration";
		}
	}

	/**
	 * Solves a single problem generated randomly by the generator passed as argument to the constructor.
	 */
	void ProblemSolver::solve() {
		Problem* problem = this->generator->generate();
		DEBUG_ASSERT_NOT_NULL(problem);
		this->solve(problem);
	}

	#define BARWIDTH 70
	#define BAR_COLOR(bar_char) COLOR_CYAN(bar_char)
	/**
	 * Prints a progress bar.
	 */
	void printProgressBar(float progress) {
		std::cout << "[";
		int pos = BARWIDTH * progress;
		for (int i = 0; i < BARWIDTH; ++i) {
			if (i < pos) std::cout << BAR_COLOR("=");
			else if (i == pos) std::cout << BAR_COLOR(">");
			else std::cout << " ";
		}
		std::cout << "] " << int(progress * 100.0) << " %\r";
		std::cout.flush();
	}

	/**
	 * Solves a number of problems generated randomly by the generator passed as argument to the constructor.
	 */
	void ProblemSolver::solveSeries(unsigned int number) {
		DEBUG_MARK_PHASE("Risoluzione di una serie di problemi") {
		std::cout << "Solving " << std::to_string(number) << " problems...\n";
		printProgressBar(0);
		for (int i = 0; i < number; i++) {
			this->solve();
			printProgressBar(float(i+1) / number);
			DEBUG_LOG_SUCCESS("Risolto il problema (%d)!", (i+1));
		}
		std::cout << std::endl;
		}
	}

} /* namespace quicksc */
